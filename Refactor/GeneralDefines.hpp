#pragma once
#ifndef GENERALDEFINES
#define GENERALDEFINES

#include <cstdint>
#include <Windows.h>
#include <memory>
#include <fstream>
#include <sstream>
#include <string>
#include <string_view>
#include <filesystem>
#include <span>
#include <ranges>
#include <stdexcept>
#include <vector>
#include <iostream>
#include <algorithm>
#include <thread>
#include <chrono>
#include <conio.h>


using namespace std::chrono_literals;

// Single byte bit masks
static constexpr uint8_t BIT0MASK = 0b00000001U;
static constexpr uint8_t BIT1MASK = 0b00000011U;
static constexpr uint8_t BIT2MASK = 0b00000111U;
static constexpr uint8_t BIT3MASK = 0b00001111U;
static constexpr uint8_t BIT4MASK = 0b00011111U;
static constexpr uint8_t BIT5MASK = 0b00111111U;
static constexpr uint8_t BIT6MASK = 0b01111111U;
static constexpr uint8_t BIT7MASK = 0b11111111U;

// Single byte bit shifts
static constexpr uint8_t BIT1SHIFT = 0x01U;
static constexpr uint8_t BIT2SHIFT = 0x02U;
static constexpr uint8_t BIT3SHIFT = 0x03U;
static constexpr uint8_t BIT4SHIFT = 0x04U;
static constexpr uint8_t BIT5SHIFT = 0x05U;
static constexpr uint8_t BIT6SHIFT = 0x06U;
static constexpr uint8_t BIT7SHIFT = 0x07U;

// Single byte bit values
static constexpr uint8_t BIT0 = 0b00000001U;
static constexpr uint8_t BIT1 = 0b00000010U;
static constexpr uint8_t BIT2 = 0b00000100U;
static constexpr uint8_t BIT3 = 0b00001000U;
static constexpr uint8_t BIT4 = 0b00010000U;
static constexpr uint8_t BIT5 = 0b00100000U;
static constexpr uint8_t BIT6 = 0b01000000U;
static constexpr uint8_t BIT7 = 0b10000000U;


/**
* @brief This is a union to help pack and unpack bits from a byte.
* This is mostly to reduce code and help make things more readable.
*/
union BitBreakDown
{
	uint8_t value;
	struct
	{
		uint8_t r0 : 2; // Range 0:1
		uint8_t r1 : 2; // Range 2:3 
		uint8_t r2 : 2; // Range 4:5 
		uint8_t r3 : 2; // Range 6:7
	};

	explicit BitBreakDown( uint8_t iValue ): value( iValue ) {}
	BitBreakDown(): value( 0x0 ) {}

	/**
	* @brief Gets 1 byte from packed bits.
	* @return The byte value.
	*/
	uint8_t GetBytes( const std::span<uint8_t>& chunk )
	{
		this->value = 0x0;
		this->r0 = ( chunk[ 0x0 ] & BIT1MASK );
		this->r1 = ( chunk[ 0x01 ] & BIT1MASK );
		this->r2 = ( chunk[ 0x02 ] & BIT1MASK );
		this->r3 = ( chunk[ 0x03 ] & BIT1MASK );

		return this->value;
	}

	/**
	* @brief packs 1 byte into 4 bytes, using 2 LSB's of each byte.
	*/
	void SetBytes( const uint8_t& iValue, std::span<uint8_t>& chunk )
	{
		this->value = iValue;
		SetBits<0x0>( chunk );
		SetBits<0x01>( chunk );
		SetBits<0x02>( chunk );
		SetBits<0x03>( chunk );
	}

	/**
	* @brief Helper function to set bits in the chunk.
	*/
	template< size_t N >
	void SetBits( std::span<uint8_t>& data ) const
	{
		data[ N ] &= ~BIT1MASK;
		if constexpr ( N == 0 )
		{
			data[ N ] |= ( this->r0 & BIT1MASK );
		} else if constexpr ( N == 1 )
		{
			data[ N ] |= ( this->r1 & BIT1MASK );
		} else if constexpr ( N == 2 )
		{
			data[ N ] |= ( this->r2 & BIT1MASK );
		} else if constexpr ( N == 3 )
		{
			data[ N ] |= ( this->r3 & BIT1MASK );
		} else
		{
			throw std::out_of_range( "BitBreakDown: Index out of range in SetBits" );
		}
	}
};


/**
* @brief Prints a buffer of bytes in hexadecimal format.
*/
template<class T>
requires ( std::is_same_v<T, std::vector<uint8_t>> || 
std::is_same_v<T, std::span<uint8_t>> || std::ranges::range<T> ) 
static void PrintBuffer( __in T bytes )
{

	for ( int i = 0; i < bytes.size(); i++ )
	{
		if ( i >= bytes.size() ) [[unlikely]]
		{
			throw std::out_of_range( "Index out of range in PrintBuffer" );
		}
		
		if ( i % 16 == 0 )
		{
			std::cout << "\n\t";
		}
		if ( i < bytes.size() - 1 )
		{
			std::cout << std::format( "0x{:X}, ", bytes[ i ] );
		} else
		{
			std::cout << std::format( "0x{:X} ", bytes[ i ] );
		}
	}

	std::cout << std::endl;
}


// >MsVenom Calculator shellcode<
//0xFC 0x48 0x83 0xE4 0xF0 0xE8 0xC0 0x00 0x00 0x00 0x41 0x51
//0x41 0x50 0x52 0x51 0x56 0x48 0x31 0xD2 0x65 0x48 0x8B 0x52
//0x60 0x48 0x8B 0x52 0x18 0x48 0x8B 0x52 0x20 0x48 0x8B 0x72
//0x50 0x48 0x0F 0xB7 0x4A 0x4A 0x4D 0x31 0xC9 0x48 0x31 0xC0
//0xAC 0x3C 0x61 0x7C 0x02 0x2C 0x20 0x41 0xC1 0xC9 0x0D 0x41
//0x01 0xC1 0xE2 0xED 0x52 0x41 0x51 0x48 0x8B 0x52 0x20 0x8B
//0x42 0x3C 0x48 0x01 0xD0 0x8B 0x80 0x88 0x00 0x00 0x00 0x48
//0x85 0xC0 0x74 0x67 0x48 0x01 0xD0 0x50 0x8B 0x48 0x18 0x44
//0x8B 0x40 0x20 0x49 0x01 0xD0 0xE3 0x56 0x48 0xFF 0xC9 0x41
//0x8B 0x34 0x88 0x48 0x01 0xD6 0x4D 0x31 0xC9 0x48 0x31 0xC0
//0xAC 0x41 0xC1 0xC9 0x0D 0x41 0x01 0xC1 0x38 0xE0 0x75 0xF1
//0x4C 0x03 0x4C 0x24 0x08 0x45 0x39 0xD1 0x75 0xD8 0x58 0x44
//0x8B 0x40 0x24 0x49 0x01 0xD0 0x66 0x41 0x8B 0x0C 0x48 0x44
//0x8B 0x40 0x1C 0x49 0x01 0xD0 0x41 0x8B 0x04 0x88 0x48 0x01
//0xD0 0x41 0x58 0x41 0x58 0x5E 0x59 0x5A 0x41 0x58 0x41 0x59
//0x41 0x5A 0x48 0x83 0xEC 0x20 0x41 0x52 0xFF 0xE0 0x58 0x41
//0x59 0x5A 0x48 0x8B 0x12 0xE9 0x57 0xFF 0xFF 0xFF 0x5D 0x48
//0xBA 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x48 0x8D 0x8D
//0x01 0x01 0x00 0x00 0x41 0xBA 0x31 0x8B 0x6F 0x87 0xFF 0xD5
//0xBB 0xE0 0x1D 0x2A 0x0A 0x41 0xBA 0xA6 0x95 0xBD 0x9D 0xFF
//0xD5 0x48 0x83 0xC4 0x28 0x3C 0x06 0x7C 0x0A 0x80 0xFB 0xE0
//0x75 0x05 0xBB 0x47 0x13 0x72 0x6F 0x6A 0x00 0x59 0x41 0x89
//0xDA 0xFF 0xD5 0x63 0x61 0x6C 0x63 0x00


#endif // !GENERALDEFINES

